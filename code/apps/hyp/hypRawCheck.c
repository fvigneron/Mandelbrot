//
//  hypCheck.c
//
//  Authors: Nicolae Mihalache, François Vigneron
//
//  Please cite the references below if you use or distribute this software.
//
//  • [1] N. Mihalache & F. Vigneron. How to split a tera-polynomial. 2021.
//  • [2] N. Mihalache & F. Vigneron. How to compute the coefficients of holomorphic maps. 2021.
//
//  Copyright 2019 - 2021 Univ. Paris-Est Créteil, Univ. de Reims Champagne-Ardenne.
//  This software is released under the GNU Public Licence v3.0
//

#include <sys/timeb.h>
#include <stdlib.h>

#include "hypRawCheck.h"
#include "hypRaw.h"
#include "nSet.h"
#include "stopWatch.h"
#include "treeMap.h"
#include "mandel.h"
#include "nset2csv.h"

// MARK: static functions

/// @brief Checks that the map stored in the correponding file equals the map of @c ps.
///
/// @param per the period
/// @param job the job index
/// @param ps the set of points
///
/// @return @ref true if the points map in the file is correct, @ref false otherwise
static bool checkMap(int per, int job, nset_t ps) {
    // construct the tree from the n2Set
    struct timeb ts;
    ftime(&ts);
    char time[100];
    
    tmap tr = tmap_map(ps, HYP_RAW_TMAP_MAX_LEVEL, HYP_RAW_TMAP_LEVEL_STEP);
    
    bool ok = tr != NULL;
    if(! ok) {
        printf("Could not construct the treeMap.\n");
    } else {
        lapse(&ts, time);
        printf("Map created in %s\n", time);
    }
    
    // load the map
    char fn[100];
    ftime(&ts);
    
    hyp_raw_map_file_name(fn, 99, per, job);
    tmap map = tmap_load(fn, 0, false, NULL);
    
    int fok = map != NULL;
    if(! fok) {
        printf("Could not read %s\n", fn);
    } else {
        lapse(&ts, time);
        printf("%s read in %s\n", fn, time);
        
        if(tr != NULL) {
            if(tmap_eq(tr, map)) {
                printf("The map file is correct.\n");
            } else {
                printf("The map file is DAMAGED !!!\n");
            }
        }
    }
        
    if(ok && ! fok) {
        ftime(&ts);
        
        if(tmap_save(tr, fn)) {
            lapse(&ts, time);
            printf("New map file written in %s\n", time);
        }
    }
        
    tmap_free(tr);
    tmap_free(map);
    
    return ok;
}

/// @brief Loads the set of hyperbolic centers of period @c per, generated by the given @c job and
/// stores the points in @c ps.
///
/// Prints the time needed to load or the eventual error message.
///
/// @param ps the destination
/// @param per the period
/// @param job the job index
///
/// @return @ref true if the points map in the file is correct, @ref false otherwise
static bool loadNSet(nset_t ps, int per, int job) {
    struct timeb ts;
    ftime(&ts);

    char fn[100], time[100];
    int fok = hyp_raw_job_file_name(fn, 99, per, job) > 10;
    fok = fok && nset_read(ps, fn, false);
    
    if(! fok) {
        printf("Could not read %s\n", fn);
        
        return false;
    } else {
        lapse(&ts, time);
        printf("%s read in %s\n", fn, time);
    }
    
    return true;
}

/// @brief Refines and writes the hyperbolic centers of period @c per, issued by @c job, found in @c ps.
///
/// Prints the time needed to complete or an eventual error message.
///
/// @param per the period
/// @param job the job index
/// @param ps the set of points
///
/// @return @ref true if the points map in the file is correct, @ref false otherwise
static int refineNSet(int per, int job, nset_t ps) {
    struct timeb ts;
    ftime(&ts);

    char fn[100], time[100];
    ulong me = 0;
    int fok = hyp_refine_nset(ps, per, &me);
    fok = fok && hyp_raw_job_file_name(fn, 99, per, job) > 10;
    fok = fok && nset_write(ps, fn);
    
    if(! fok) {
        printf("Could not refine and write %s\n", fn);
        
        return false;
    } else {
        lapse(&ts, time);
        printf("%s refined and saved in %s (max error %ld LSB)\n", fn, time, me);
    }
    
    return true;
}

/// @brief Checks the results of @c hypRawMain() for period @c per for jobs strating at @c st and ending at @c en-1.
///
/// Optionally, it refines the results and writem the back.
///
/// @param per the period
/// @param st the fist job
/// @param en the last job @c +1
/// @param ref @c 1 to refine and write the hyperbolic centers, @c 0 to skip this step
///
/// @return @ref true if successfull, @ref false otherwise
static bool check(int per, int st, int en, int ref) {
    struct timeb ats;
    ftime(&ats);
    char time[100];
    
    bool ok = true, mok = true;
    
    nSet_struct ps[en - st];
    long cnt = 0, rcnt = 0;
    
    for (int j = st; j < en; j++) {
        nset_init(&ps[j - st], HYP_RAW_SET_EPS);
        
        if(! loadNSet(&ps[j - st], per, j)) {
            ok = false;
            nset_clear(&ps[j - st]);
            
            continue;
        }
        
        if(ref) {
            ok = refineNSet(per, j, &ps[j - st]) && ok;
        }
        
        cnt += ps[j - st].count;
        rcnt += ps[j - st].realCount;
        
        if(! checkMap(per, j, &ps[j - st])) {
            mok = false;
        }
        
        nset_clear(&ps[j - st]);
        
        printf("\n");
    }
    
    if(ok && mok) {
        if(en - st > 1) {
            if(en - st == 2) {
                printf("Both files + maps are OK and contain %ld points (%ld real).\n",
                       cnt, rcnt);
            } else {
                printf("All %d files + maps are OK and contain %ld points (%ld real).\n",
                       en - st, cnt, rcnt);
            }
        }
    } else {
        printf("Some of the files are damaged or missing.\n");
    }
    
    lapse(&ats, time);
    printf("Total loading and map checking time: %s\n\n", time);
    fflush(stdout);
    
    return ok;
}

// MARK: the help system and the main function

static const char* before = "This task checks and refines the hyperbolic centers files of given period, as follows:\n\n";
static const char* after = "\nOptionally, it refines the results.\n\n";

static const char *parameters[] = {
    "period",
    "start",
    "end",
    "refine"
};

static const char *types[] = {
    "required",
    "optional",
    "optional",
    "optional"
};

static const char *defaults[] = {
    "",
    "0",
    "jobs count",
    "0"
};

static const char *descriptions[] = {
    "the period, integer, at least 1, at most 41",
    "start job >= 0, inclusive; default value = 0",
    "end job <= 1 << (period - 27), exclusive; default value = jobs count",
    "refine: 1 to refine the precision of centers, 0 to skip this"
};

static const char *headers[] = {
    "Parameter",
    "Type",
    "Default value",
    "Description"
};

static const int paramCount = 4;
static const int columnWidths[] = {18, 18, 18};

/// Prints instructions for usage and some details about the command line arguments.
static void help(void) {
    printf("%s", before);
    char format[50];
    snprintf(format, 45, "    %%-%ds %%-%ds %%-%ds %%s\n",
             columnWidths[0], columnWidths[1], columnWidths[2]);
    
    printf(format, headers[0], headers[1], headers[2], headers[3]);
    printf("\n");
    for(int i = 0; i < paramCount; i++) {
        printf(format, parameters[i], types[i], defaults[i], descriptions[i]);
    }
    
    printf("%s", after);
}

int hyp_check_main(int argc, const char * argv[]) {
    int per, start, end, ref = 0;
    
    if(argc < 1 || sscanf(argv[0], "%d", &per) < 1 || per < 1 || per > HYP_RAW_MAX_PER) {
        help();
        
        return 1;
    }
    
    int jobs = per < 28 ? 1 : 1 << (per - 27);
    if(argc >= 3) {
        if(sscanf(argv[1], "%d", &start) < 1 || sscanf(argv[2], "%d", &end) < 1 ||
           per < 1 || per > HYP_RAW_MAX_PER || start < 0 || end <= start || end > jobs) {
               help();
               
               return 1;
        }
    } else {
        start = 0;
        end = jobs;
    }
    
    if(argc >= 4) {
        if(sscanf(argv[3], "%d", &ref) < 1 || (ref != 0 && ref != 1)) {
               help();
               
               return 1;
        }
    }
    
    return ! check(per, start, end, ref);
}
